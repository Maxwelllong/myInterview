# JavaScript面试题

## 1.假设有如下代码，那么a(10)的返回结果是？

```js
function a(a){
    a^=(1<<4)-1;
    return a;
}

```

题解：

1.考察点：二进制，异或(^)使用,二级制符号移位。

2.解题思路：将1转化为二进制然后移位，再与a进行异或。在之后进行运算求值。

3.1转化为二进制为01，向左侧移动4位变成10000，变成了十进制的16（2的3次方），减一变成15（1111），然后和a（1010）进行异或变成（0101）返回二进制的（0101）十进制为5

## 2.内存回收方式以及原理？

js内存回收方式主要有两种：计数引用和标记清除

1. 计数引用

   ​	引用计数的判断原理很简单，就是看一份数据是否还有指向它的引用，如果没有任何对象再指向它，那么垃圾回收器就会回收。

   ```js
   // 创建一个对象，由变量o指向这个对象的两个属性
   var o = {
       name: '听风是风',
       handsome: true
   };
   // name虽然设置为了null，但o依旧有name属性的引用
   o.name = null;
   var s = o;
   // 我们修改并释放了o对于对象的引用，但变量s依旧存在引用
   o = null;
   // 变量s也不再引用，对象很快会被垃圾回收器释放
   s = null;
   ```

   引用计数存在一个很大的问题，就是对象间的循环引用，比如如下代码中，对象o1与o2相互引用，即便函数执行完毕，垃圾回收器通过引用计数也无法释放它们。

   ```js
   function f() {
       var o1 = {};
       var o2 = {};
       o1.a = o2; // o1 引用 o2
       o2.a = o1; // o2 引用 o1
       return;
   };
   f();
   ```

2. 标记清除

   ​	标记清除的概念也好理解，从根部出发看是否能达到某个对象，如果能达到则认定这个对象还被需要，如果无法达到，则释放它。

   总共分为三步：

   ​	a.垃圾回收器创建roots列表，roots通常是代码中保留引用的全局变量，在js中，我们一般认定全局对象window作为root，也就是所谓的根部。

   ​	b.从根部出发检查所有 的roots，所有的children也会被递归检查，能从root到达的都会被标记为active。

   ​	c.未被标记为active的数据被认定为不再需要，垃圾回收器开始释放它们。

参考资料

-  :+1: 从内存谈到垃圾回收机制 https://www.cnblogs.com/echolun/p/11503915.html

## 3.那些情况下会造成内存泄漏？

```text
一.内存泄漏情况
	1.定时器不用的时候没有清零会造成内存泄漏；
	2.闭包。因为在闭包中某个元素至少引用一次，就会造成无法进行清理。
	3.DOM对象泄漏;
	4.全局变量;
二.主要关注的代码点
	1.DOM中的addEventLisner 函数及派生的事件监听， 比如Jquery 中的on 函数， vue 组件实例的 $on 函数，第三方库中的初始化函数
	2.BOM对象的事件监听，比如webSocket的监听事件
	3.避免不必要的函数引用
	4.如果是要render函数，避免在html标签中DOM / BOM事件
三.在vue中如何处理内存泄漏的
	1.如果在mounted/created 钩子中绑定了DOM/BOM 对象中的事件，需要在beforeDestroy 中做对应解绑处理
如果在mounted/created 钩子中使用了第三方库初始化，需要在beforeDestroy 中做对应销毁处理
	2.如果组件中使用了定时器，需要在beforeDestroy 中做对应销毁处理
	3.模板中不要使用表达式来绑定到特定的处理函数，这个逻辑应该放在处理函数中
	4.如果在mounted/created 钩子中使用了$on，需要在beforeDestroy 中做对应解绑($off)处理某些组件在模板中使用 事件绑定可能会出现泄漏，使用$on 替换模板中的绑定

```

## eventLoop 知道吗？解释一下

